#include "common.h"
#include "navmesh.h"

float _WMeshG(ANode* from, ANode* to)
{
    WVertexData* fdata = from->data;
    WVertexData* tdata = to->data;

    float dx = tdata->x - (float)fdata->x;
    float dy = tdata->y - (float)fdata->y;
    return from->score.g + sqrt(dx*dx + dy*dy);
}
float _WMeshH(ANode* from, ANode* to)
{
    WVertexData* fdata = from->data;
    WVertexData* tdata = to->data;

    float dx = tdata->x - (float)fdata->x;
    float dy = tdata->y - (float)fdata->y;
    return sqrt(dx*dx + dy*dy);
}
int _WMeshGoal(ANode* from, ANode* to)
{
    return from == to;
}

int WLineIntersects(float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4, float* xp, float* yp)
{
    if((!(BOUNDS(x1, x2, x3) || BOUNDS(x1, x2, x4)) || !(BOUNDS(y1, y2, y3) || BOUNDS(y1, y2, y4)))
    && (!(BOUNDS(x3, x4, x1) || BOUNDS(x3, x4, x2)) || !(BOUNDS(y3, y4, y1) || BOUNDS(y3, y4, y2))))
        return 0;

    float f1 = x1*y2 - y1*x2;
    float f2 = x3*y4 - y3*x4;
    float x1m = x1 - x2;
    float y1m = y1 - y2;
    float x3m = x3 - x4;
    float y3m = y3 - y4;

    float den = x1m * y3m - y1m * x3m;
    float x = (f1 * x3m - f2 * x1m) / den;
    float y = (f1 * y3m - f2 * y1m) / den;

    if(xp != NULL)
        *xp = x;
    if(yp != NULL)
        *yp = y;

    return BOUNDS(x1, x2, x) && BOUNDS(x3, x4, x) && BOUNDS(y1, y2, y) && BOUNDS(y3, y4, y);
}

int WPolyInside(float* px, float* py, size_t numpoints, float x, float y)
{
    size_t i, j, c = 0;
    for (i = 0, j = numpoints-1; i < numpoints; j = i++)
    {
        if (((py[i]>y) != (py[j]>y))
        &&   (x < (px[j]-px[i]) * (y-py[i]) / (py[j]-py[i]) + px[i]))
        c = !c;
    }
    return c;
}

WMesh* WPolyCreate(float* x, float* y, size_t numpoints)
{
    WMesh* mesh = malloc(sizeof(WMesh));
    mesh->search = NULL;
    mesh->links = NULL;
    mesh->numlinks = 0;
    mesh->verts = malloc(numpoints * sizeof(WVertex*));
    mesh->numverts = numpoints;
    mesh->edges = malloc(numpoints * sizeof(WEdge*));
    mesh->numedges = numpoints;
    mesh->faces = malloc(sizeof(WFace*));
    mesh->numfaces = 1;

    ptrdiff_t i;
    for(i = 0; i < numpoints; i++)
    {
        mesh->verts[i] = malloc(sizeof(WVertex));
        mesh->verts[i]->verts = malloc(2 * sizeof(WVertex*));
        mesh->verts[i]->numverts = 2;
        mesh->verts[i]->edges = malloc(2 * sizeof(WEdge*));
        mesh->verts[i]->numedges = 2;
        mesh->verts[i]->faces = malloc(sizeof(WFace*));
        mesh->verts[i]->numfaces = 1;
        mesh->verts[i]->data = malloc(sizeof(WVertexData));
        mesh->verts[i]->data->links = NULL;
        mesh->verts[i]->data->numlinks = 0;

        mesh->edges[i] = malloc(sizeof(WEdge));
        mesh->edges[i]->data = malloc(sizeof(WEdgeData));
        mesh->edges[i]->data->links = NULL;
        mesh->edges[i]->data->numlinks = 0;
    }

    mesh->faces[0] = malloc(sizeof(WFace));
    mesh->faces[0]->verts = malloc(numpoints * sizeof(WVertex));
    mesh->faces[0]->numverts = numpoints;
    mesh->faces[0]->edges = malloc(numpoints * sizeof(WEdge));
    mesh->faces[0]->numedges = numpoints;
    mesh->faces[0]->faces = NULL;
    mesh->faces[0]->numfaces = 0;
    mesh->faces[0]->data = malloc(sizeof(WFaceData));
    mesh->faces[0]->data->links = NULL;
    mesh->faces[0]->data->numlinks = 0;
    for(i = 0; i < numpoints; i++)
    {
        mesh->verts[i]->verts[0] = mesh->verts[(i-1+numpoints) % numpoints];
        mesh->verts[i]->verts[1] = mesh->verts[(i+1) % numpoints];
        mesh->verts[i]->edges[0] = mesh->edges[(i-1+numpoints) % numpoints];
        mesh->verts[i]->edges[1] = mesh->edges[i];
        mesh->verts[i]->faces[0] = mesh->faces[0];
        mesh->verts[i]->data->x = x[i];
        mesh->verts[i]->data->y = y[i];

        mesh->edges[i]->vert1 = mesh->verts[i];
        mesh->edges[i]->vert2 = mesh->verts[(i+1) % numpoints];
        mesh->edges[i]->face1 = mesh->faces[0];
        mesh->edges[i]->face2 = NULL;

        mesh->faces[0]->verts[i] = mesh->verts[i];
        mesh->faces[0]->edges[i] = mesh->edges[i];
    }

    return mesh;
}
void WMeshDestroy(WMesh* mesh)
{
    size_t i;
    for(i = 0; i < mesh->numedges; i++)
    {
        free(mesh->edges[i]->data->links);
        free(mesh->edges[i]->data);
        free(mesh->edges[i]);
    }
    for(i = 0; i < mesh->numverts; i++)
    {
        free(mesh->verts[i]->verts);
        free(mesh->verts[i]->edges);
        free(mesh->verts[i]->faces);
        free(mesh->verts[i]->data->links);
        free(mesh->verts[i]->data);
        free(mesh->verts[i]);
    }
    for(i = 0; i < mesh->numfaces; i++)
    {
        free(mesh->faces[i]->verts);
        free(mesh->faces[i]->edges);
        free(mesh->faces[i]->faces);
        free(mesh->faces[i]->data->links);
        free(mesh->faces[i]->data);
        free(mesh->faces[i]);
    }
    free(mesh->links);
    free(mesh->verts);
    free(mesh->edges);
    free(mesh->faces);
    free(mesh);
}
void WMeshLink(WMesh* from, WMesh* to)
{
    WMeshUnlink(from, to); // to prevent duplication
    ARR_ADD(from->links, from->numlinks, to);

    ptrdiff_t fe, te, i;
    WEdge* fedge;
    WEdge* tedge;
    for(fe = 0; fe < from->numedges; fe++)
    {
        fedge = from->edges[fe];
        for(te = 0; te < to->numedges; te++)
        {
            tedge = to->edges[te];

#define CMP(Ax1, Ay1, Ax2, Ay2, Bx1, By1, Bx2, By2) \
        ( (((Ax1) == (Bx1)) && ((Ay1) == (By1))     \
       && ((Ax2) == (Bx2)) && ((Ay2) == (By2)))     \
       || (((Ax2) == (Bx1)) && ((Ay2) == (By1))     \
       && ((Ax1) == (Bx2)) && ((Ay1) == (By2))))

            // if the edges match...
            if(CMP(fedge->vert1->data->x, fedge->vert1->data->y, fedge->vert2->data->x, fedge->vert2->data->y
                  ,tedge->vert1->data->x, tedge->vert1->data->y, tedge->vert2->data->x, tedge->vert2->data->y))
            {
                ARR_ADD(fedge->data->links, fedge->data->numlinks, tedge);
                for(i = 0; i < to->numverts; i++)
                {
                    ARR_ADD(fedge->vert1->data->links, fedge->vert1->data->numlinks, to->verts[i]);
                    ARR_ADD(fedge->vert2->data->links, fedge->vert2->data->numlinks, to->verts[i]);
                }
                //ARR_ADD(fedge->vert1->data->links, fedge->vert1->data->numlinks, tedge->vert1);
                //ARR_ADD(fedge->vert1->data->links, fedge->vert1->data->numlinks, tedge->vert2);
                //ARR_ADD(fedge->vert2->data->links, fedge->vert2->data->numlinks, tedge->vert1);
                //ARR_ADD(fedge->vert2->data->links, fedge->vert2->data->numlinks, tedge->vert2);
            }
#undef CMP
        }
    }
}
void WMeshDlink(WMesh* one, WMesh* two)
{
    WMeshLink(one, two);
    WMeshLink(two, one);
}
void WMeshUnlink(WMesh* from, WMesh* to)
{
    size_t i;
    for(i = 0; i < from->numlinks; i++)
        if(from->links[i] == to)
        {
            ARR_REMOVE(from->links, from->numlinks, i);
            return;
        }
}
void WMeshDUnlink(WMesh* one, WMesh* two)
{
    WMeshUnlink(one, two);
    WMeshUnlink(two, one);
}

